#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Wed Feb 13 19:41:04 2019

@author: div
"""

import serial
import smbus
import time
from threading import Timer, Event, Thread
#from main_codes.message_slave import par_var
from global_var import par_var, fb_var, source_param, load_param
from main_codes.power import message_send
from global_var import parameters
from copy import deepcopy
import math
local_load_list=[]
local_source_list=[]

send_rs485_block_event = Event()
receive_rs485_block_event = Event()
state_switch_event = Event()
batt_voltage =0
def port_off(bus):
    
    par_obj=par_var()
    msg_c_obj = message_send()
    print "Inside port_off function"
    for rows in range(len(local_load_list)):
        
        if(local_load_list[rows].state == par_obj.STOP_UPDATE_STATE):
            print "_____________________________"
            if(local_load_list[rows].port=="1"):
                print "_________________Sending stop port 1"
                send_rs485_block_event.wait()
                if send_rs485_block_event.is_set():
                    print ("|||||||||||||||||||||||||   block event set from port_off |||||||||||||||||||||||")
                    msg_c_obj.send_i2c(bus,par_obj.slaveid[0],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
                
            elif(local_load_list[rows].port=="2"):
                print "___________________Sending stop port 2"
                send_rs485_block_event.wait()
                if send_rs485_block_event.is_set():
                    print ("|||||||||||||||||||||||||   block event set from port_off |||||||||||||||||||||||")
                    msg_c_obj.send_i2c(bus,par_obj.slaveid[1],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
            elif(local_load_list[rows].port=="3"):
                print "___________________Sending stop port 3"
                send_rs485_block_event.wait()
                if send_rs485_block_event.is_set():
                    print ("|||||||||||||||||||||||||   block event set from port_off |||||||||||||||||||||||")
                    msg_c_obj.send_i2c(bus,par_obj.slaveid[2],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)

                
    for rows in range(len(local_source_list)):
        if(local_source_list[rows].state == par_obj.STOP_UPDATE_STATE):
            if(local_source_list[rows].port=="1"):
                print "__________________Sending stop port 1"
                send_rs485_block_event.wait()
                if send_rs485_block_event.is_set():
                    print ("|||||||||||||||||||||||||   block event set from port_off |||||||||||||||||||||||")
                    msg_c_obj.send_i2c(bus,par_obj.slaveid[0],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
            elif(local_source_list[rows].port=="2"):
                print "__________________Sending stop port 2"
                send_rs485_block_event.wait()
                if send_rs485_block_event.is_set():
                    print ("|||||||||||||||||||||||||   block event set from port_off |||||||||||||||||||||||")
                    msg_c_obj.send_i2c(bus,par_obj.slaveid[1],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
            elif(local_source_list[rows].port=="3"):
                print "__________________Sending stop port 3"
                send_rs485_block_event.wait()
                if send_rs485_block_event.is_set():
                    print ("|||||||||||||||||||||||||   block event set from port_off |||||||||||||||||||||||")
                    msg_c_obj.send_i2c(bus,par_obj.slaveid[2],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)

def state_switch(bus,change_type,Source_list,Load_list):
    
    par_obj = par_var()
    msg_c_obj = message_send()
    print "In the loop for changing the state of the switches"
    
    total_amp_av=0
    total_load_rq=0
    voltage=14
    
    #~ print par_obj.CURRENT
    
    for rows in range(len(Source_list)):
        total_amp_av += local_source_list[rows].current_aval
    
    for rows in range(len(Load_list)):
        if(local_load_list[rows].current_reqd <= par_obj.conv_max_current):                
            total_load_rq += local_load_list[rows].current_reqd
            local_load_list[rows].actual_curr = local_load_list[rows].current_reqd
            #~ print("***********_________ local_load_list[rows].actual_curr_________ ***********",local_load_list[rows].actual_curr)
        else:
            total_load_rq += par_obj.conv_max_current
            local_load_list[rows].actual_curr = par_obj.conv_max_current
            #~ print("***********_________ local_load_list[rows].actual_curr_________ ***********",local_load_list[rows].actual_curr)
##    print "loop"
##    star ='*' * 50
##    print (star)
##    print ("TOTAL AMP AVAILABLE")
##    print total_amp_av
##    print (star)
##    print ("TOTAL AMP REQUIRED")
##    print total_load_rq
##    print (star)
#    print i
    
    if not local_load_list:
        send_rs485_block_event.wait()
        if send_rs485_block_event.is_set():
            print ("|||||||||||||||||||||||||   block event set from state_switch -> not local load |||||||||||||||||||||||")
            msg_c_obj.send_i2c(bus,par_obj.slaveid[0],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
        send_rs485_block_event.wait()
        if send_rs485_block_event.is_set():
            print ("|||||||||||||||||||||||||   block event set from state_switch -> not local load |||||||||||||||||||||||")
            msg_c_obj.send_i2c(bus,par_obj.slaveid[1],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
        send_rs485_block_event.wait()
        if send_rs485_block_event.is_set():
            print ("|||||||||||||||||||||||||   block event set from state_switch -> not local load |||||||||||||||||||||||")
            #~ msg_c_obj.send_i2c(bus,par_obj.slaveid[2],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)

    elif local_load_list:
        print "Entered state switch containing local loads"
        if(total_amp_av>=total_load_rq):
            if total_amp_av!=0:
                mul_factor=total_load_rq/total_amp_av
                print ("_____________MUL_factor_________",mul_factor)
            else:
                mul_factor=0
    #        print "if complete"
            for rows in range(len(local_load_list)):
                print ("local_load_list____________",vars(local_load_list[rows]))
                if(local_load_list[rows].state == par_obj.PARAM_UPDATE_STATE):
        
                    if(local_load_list[rows].port == "1"):
                        current = local_load_list[rows].actual_curr
                        voltage = local_load_list[rows].voltage
                        data=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.LOAD_DIRECTION]
                        data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]    
                        message=msg_c_obj.msg_pack(data,data_type_order)
                        
                        print "slave id"  + str(par_obj.slaveid[0])
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local load list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[0],par_obj.PARAM_COMMAND,message,send_rs485_block_event)    
                    elif(local_load_list[rows].port == "2"):
                        current = local_load_list[rows].actual_curr
                        voltage = local_load_list[rows].voltage
                        data=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.LOAD_DIRECTION]
                        data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]    
                        message=msg_c_obj.msg_pack(data,data_type_order)
                        
                        print "slave id"  + str(par_obj.slaveid[1])
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local load list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[1],par_obj.PARAM_COMMAND,message,send_rs485_block_event) 
                        
                    elif(local_load_list[rows].port == "3"):
                        current = local_load_list[rows].actual_curr
                        voltage = local_load_list[rows].voltage
                        data=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.LOAD_DIRECTION]
                        data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]    
                        message=msg_c_obj.msg_pack(data,data_type_order)
                        
                        print "slave id"  + str(par_obj.slaveid[2])
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local load list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[2],par_obj.PARAM_COMMAND,message,send_rs485_block_event)    

                elif(local_load_list[rows].state == par_obj.STOP_UPDATE_STATE):
                    if(local_load_list[rows].port=="1"):
                        print "Sending start port 1"
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local load list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[0],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
                        local_load_list.pop(rows)
                        
                    elif(local_load_list[rows].port=="2"):
                        print "Sending start port 2"
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local load list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[1],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
                        local_load_list.pop(rows)
                    elif(local_load_list[rows].port=="3"):
                        print "Sending start port 3"
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local load list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[2],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
                        local_load_list.pop(rows)        
            for rows in range(len(local_source_list)):
                #~ print ("local_source_list all values", local_source_list)
                #~ print ("local_source_list____________",vars(local_source_list[rows]))
                if(local_source_list[rows].state == par_obj.PARAM_UPDATE_STATE):
    #                print ("1st enter if loop")
    #                print type(local_source_list[rows].port)
                    if(local_source_list[rows].port == "1"):
    #                    print"2nd enter if loop"
    #                    print mul_factor
                        local_source_list[rows].actual_curr = local_source_list[rows].current_aval * mul_factor
                        voltage= local_source_list[rows].voltage
                        current = local_source_list[rows].actual_curr
                        
                        #~ print("***********_________ source_list[rows].actual_curr_________ ***********",current)
                        data=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.SOURCE_DIRECTION]
    #                    data=[14,2.4,par_obj.SOURCE_DIRECTION]
                        data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]    
                        message=msg_c_obj.msg_pack(data,data_type_order)
                        
                        #print "slave id"  + str(par_obj.slaveid[0])
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local source list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[0],par_obj.PARAM_COMMAND,message,send_rs485_block_event)    
                    elif(local_source_list[rows].port == "2"):
                        print mul_factor
                        local_source_list[rows].actual_curr = local_source_list[rows].current_aval * mul_factor
                        voltage= local_source_list[rows].voltage
                        current = local_source_list[rows].actual_curr
                        
                        data=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.SOURCE_DIRECTION]
                        data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]    
                        message=msg_c_obj.msg_pack(data,data_type_order)
                        
                        print "slave id"  + str(par_obj.slaveid[1])
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local source list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[1],par_obj.PARAM_COMMAND,message,send_rs485_block_event)

                    elif(local_source_list[rows].port == "3"):
                        print mul_factor
                        local_source_list[rows].actual_curr = local_source_list[rows].current_aval * mul_factor
                        voltage= local_source_list[rows].voltage
                        current = local_source_list[rows].actual_curr
                        
                        data=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.SOURCE_DIRECTION]
                        data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]    
                        message=msg_c_obj.msg_pack(data,data_type_order)
                        
                        print "slave id"  + str(par_obj.slaveid[2])
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local source list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[2],par_obj.PARAM_COMMAND,message,send_rs485_block_event) 
                        

                elif(local_source_list[rows].state == par_obj.STOP_UPDATE_STATE):
                    if(local_source_list[rows].port=="1"):
                        print "Sending start port 1"
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local source list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[0],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
                        local_source_list.pop(rows)
                        
                    elif(local_source_list[rows].port=="2"):
                        print "Sending start port 1"
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local source list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[1],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
                        local_source_list.pop(rows)
                    
                    elif(local_source_list[rows].port=="3"):
                        print "Sending start port 1"
                        send_rs485_block_event.wait()
                        if send_rs485_block_event.is_set():
                            print ("|||||||||||||||||||||||||   block event set from state_switch -> local source list |||||||||||||||||||||||")
                            msg_c_obj.send_i2c(bus,par_obj.slaveid[2],par_obj.STOP_COMMAND,[ord("0")],send_rs485_block_event)
                        local_source_list.pop(rows)
            time.sleep(0.01)
        
        
        
        
#    if(i==1):
#        time.sleep(5)
#        Load_list[0].state=par_obj.STOP_UPDATE_STATE
#        Source_list[0].state=par_obj.STOP_UPDATE_STATE
#    elif(i==0):
#        time.sleep(1)
#    i=i+1     

#i=0

    
        
def batt_voltage_f(bus):
    global batt_voltage
    while True:
        batt_voltage=14.2
#        print "Battery_voltage Thread"
        time.sleep(1)

def poll_slave_f(bus,Feedback_list):
    global local_source_list
    param=[]
    value_received = []
#    par_obj = par_var()
    msg_c_obj = message_send()
    par_obj = par_var()
    time.sleep(5)
    print "Sending poll thread"
#    msg_c_obj.send_i2c(bus,0x32,0x80,[0])
#    time.sleep(3)
#    x=msg_c_obj.receive_i2c(bus,0x32,0x23,8)
#    param=msg_c_obj.msg_unpack(x,2)
#    print param
    while True:
        state_switch_event.wait()
        if state_switch_event.is_set():
            for slave in range(len(par_obj.slaveid)):
                message_send_poll =[0]
                send_rs485_block_event.wait()
                if send_rs485_block_event.is_set():
                    print ("|||||||||||||||||||||||||   poll slave function |||||||||||||||||||||||")
                    value_received= msg_c_obj.send_i2c(bus,par_obj.slaveid[slave],0x80,message_send_poll,send_rs485_block_event)
                if value_received[0]:
                    param=msg_c_obj.msg_unpack(value_received[1],4)
    #                print param
    #                
    #                print slave 
                if param :               
                    if not math.isnan(param[0]):
                        Feedback_list[slave].voltage_port1 = param[0]*3.3*6.741/4096
                        #~ print ("Feedback", Feedback_list[slave].voltage_port1)
                    else:
                        Feedback_list[slave].voltage_port1 = 0
                    if not math.isnan(param[1]):
                        Feedback_list[slave].voltage_port2 = param[1]*3.3*6.741/4096
                    else:
                        Feedback_list[slave].voltage_port2 = 0
                    if not math.isnan(param[2]):
                        Feedback_list[slave].current_port1 = param[2]
                    else:
                        Feedback_list[slave].current_port1 = 0
                    if not math.isnan(param[3]):
                        Feedback_list[slave].current_port2 = param[3] 
                    else:
                        Feedback_list[slave].current_port1 = 0
                    """
                    print("************* poll slave thread******************")
                    print par_obj.slaveid[slave]
                    print vars(Feedback_list[slave])"""
                else:
                    print("poll_slave -> param  is None")
            time.sleep(3)
    #            except:
    #                print "Error"

    #            print len(Feedback_list)
    #            for i in range(len(Feedback_list)):
    #                print "YESE"+str(i)
    #                print vars(Feedback_list[i])
    #        print "Polling"
            
def list_add_check_f(Source_list, Load_list,list_type):
    
    global local_load_list
    global local_source_list
#   For LOAD conditions
    print "*************************************"
    print "Inside list_add_check_f"
    
    if list_type==1: 

        if (len(Load_list) == 0 and len(local_load_list) == 0):
            print "Both the GLobal and Local Load list empty : NOTHING TO DO"
        elif(len(Load_list) != 0 and len(local_load_list) == 0):
            print "Local load list empty but global not empty and adding all the load in local list"
            for rows in Load_list:
                print "Appending the load in local load list"
                local_load_list.append(rows)
        elif(len(Load_list) != 0 and len(local_load_list) != 0):
            for global_i in range(len(Load_list)):
                for local_i in range(len(local_load_list)):
                    if( Load_list[global_i].id == local_load_list[local_i].id and Load_list[global_i].port == local_load_list[local_i].port):
                        print "User id matched"
                        break
                    else:
                        if( local_i == (len(local_load_list)-1)): # new user detected
                            local_load_list.append(Load_list[global_i])
                            print "New user detected"
                        else:
                            print "Error in local load list add function"
    elif list_type==2:
        
        if (len(Source_list) == 0 and len(local_source_list) == 0):
            print "Both the GLobal and Local Source list empty : NOTHING TO DO"
        elif(len(Source_list) != 0 and len(local_source_list) == 0):
            print "Local source list empty but global not empty and adding all the sources in local list"
            for rows in Source_list:
                print "Appending the source in local source list"
                local_source_list.append(rows)
        elif(len(Source_list) != 0 and len(local_source_list) != 0):
            for global_i in range(len(Source_list)):
                for local_i in range(len(local_source_list)):
                    if( Source_list[global_i].id == local_source_list[local_i].id and Source_list[global_i].port == local_source_list[local_i].port):
                        print "User id matched"
                        break
                    else:
                        if( local_i == (len(local_source_list)-1)): # new user detected
                            local_source_list.append(Source_list[global_i])
                            print "New user detected"
                        else:
                            print "Error in local source list add function"
    else:
        print("Wrong list_type")
        pass

def list_del_check_f(Source_list, Load_list,list_type):
    
    global local_load_list
    global local_source_list
    
    delete_arr=[]
    if list_type==1:
        for local_i in range(len(local_load_list)):
            #print "LOAD"
            #~ print "LOCAL_I" + str(local_i)
            if Load_list:
                for global_i in range (len(Load_list)):
                    #~ print "GLOBAL_I" + str(global_i)                    
                    if( local_load_list[local_i].id == Load_list[global_i].id and local_load_list[local_i].port == Load_list[global_i].port):
                        #~ print "DELETE: User ID Matched"
                        break
                    else:
                        if(global_i == (len(Load_list)-1)):
    #                        delete_arr.append(local_i)
                            local_load_list[local_i].state=2
                            #~ print "Load"
                            print "Deleted"
                        else:
                            pass
                            #~ print "DELETE: NO LOOP"
            else:
                #~ print ("No load in Global list")
                local_load_list[local_i].state=2
        #~ print delete_arr
#        for i in reversed(range(len(delete_arr))): # for not changing the order of list for deleting
#            local_load_list.pop(delete_arr[i])
#        pass

    elif list_type==2:    
        for local_i in range(len(local_source_list)):
            
            print "LOCAL_I" + str(local_i)
            if Source_list:
                for global_i in range (len(Source_list)):
                    print "GLOBAL_I" + str(global_i)                    
                    if( local_source_list[local_i].id == Source_list[global_i].id and local_source_list[local_i].port == Source_list[global_i].port):
                        print "DELETE: User ID Matched"
                        break
                    else:
                        if(global_i == (len(Source_list)-1)):
    #                        delete_arr.append(local_i)
                            local_source_list[local_i].state=2
                            print "Source"
                            print "Deleted"
                        else:
                            print "DELETE: NO LOOP"
            else:
                print ("No source in Global list")                
                local_source_list[local_i].state=2
        print delete_arr
 #       for i in reversed(range(len(delete_arr))):
 #           local_source_list.pop(delete_arr[i])
 #       pass
        
    else:
        print ("Wrong list_type")

#    return delete_arr

def list_update_f(Source_list, Load_list,list_type):
    
    global local_load_list
    global local_source_list
    if list_type==1:
        for local_i in range(len(local_load_list)):
            for global_i in range (len(Load_list)):
                if( local_load_list[local_i].id == Load_list[global_i].id and Load_list[global_i].port == local_load_list[local_i].port):
                    #start checking for any update
                    local_load_list[local_i] = Load_list[global_i]
                    print "UPDATED"
    elif list_type==2:
        for local_i in range(len(local_source_list)):
            for global_i in range (len(Source_list)):
                if( local_source_list[local_i].id == Source_list[global_i].id and Source_list[global_i].port == local_source_list[local_i].port):
                    #start checking for any update
                    local_source_list[local_i] = Source_list[global_i]
                    print "UPDATED"
    else:
        print("Wrong list_type")

def list_check_f(bus,Source_list, Load_list):
    load_delete_arr=[]
    source_delete_arr=[]
#   Checking for the load list change in data
    
#    print len(local_load_list)
    
    global local_load_list
    global local_source_list
    
#    if len(local_load_list) == 0:
#        if(len(Load_list)==0):
#            print "\n\nGLOBAL LIST EMPTY  | LOCAL EMPTY"
#        else:
#            for i in range(len(Load_list)):
#                local_load_list.append(Load_list[i])
#                print "\n*************************************"
#                print "\n"
#                print (vars(Load_list[i]))
#            print "\n LOCAL LIST EMPTY  | GLOBAL NOT EMPTY"
#    else:
#        if(len(Load_list) == 0):
#            print "\n GLOBAL LIST EMPTY  | LOCAL NOT EMPTY"
#            for i in range(len(local_load_list)):
#                local_load_list[i].state=2
#        else:
#    list_add_check_f(Source_list,Load_list,1)
#    list_update_f(Source_list,Load_list,1)    
#    print         
    list_del_check_f(Source_list,Load_list,1)
    list_del_check_f(Source_list,Load_list,2)
    
    for rows in local_source_list:
        print vars(rows)
    for rows in local_load_list:
        print vars(rows)
    port_off(bus)
#    for rows in load_delete_arr:
#            rows.state=2
    
    
#    if len(local_source_list) == 0:
#        if(len(Source_list)==0):
#            print "\n\nGLOBAL LIST EMPTY  | LOCAL EMPTY"
#        else:
#            for i in range(len(Source_list)):
#                local_source_list.append(Source_list[i])
#                print "\n*************************************"
#                print "\n"
#                print (vars(Source_list[i]))
#            print "\n LOCAL LIST EMPTY  | GLOBAL NOT EMPTY"
#    else:
#        if(len(Source_list) == 0):
#            print "\n GLOBAL LIST EMPTY  | LOCAL NOT EMPTY"
#            for i in range(len(local_source_list)):
#                local_source_list[i].state=2
#        else:
#    list_add_check_f(Source_list,Load_list,2)            
#    source_delete_arr= list_del_check_f(Source_list,Load_list,2)
#    list_update_f(Source_list,Load_list,2)
            
#            for rows in source_delete_arr:
#                    rows.state=2
        
#    local_load_list.append(Load_list[0])
#    print local_load_list

    
    
def table(local_load_list,local_source_list):
    
#            self.ip_address=None
#        self.port=None 
#        self.id=None 
#        self.type=None 
#        self.value=None 
#        self.min_volt=0 
#        self.max_volt=0
#        self.min_curr=0 
#        self.max_curr=0 
#        self.current_reqd=0
#        self.state=0
#        self.actual_curr=0
    dash = '-' * 40
    for i in range(len(local_load_list)):
        if i==0:
            print(dash)
            print "LOAD LIST"
            print(dash)
            print('{:<18s}{:>6s}{:>6s}{:>12s}{:>6s}{:>13s}{:>13s}'.format("IP_ADDRESS","PORT","ID","TYPE","STATE","CURRENT","ACTUAL_CURR"))
            print (dash)
        
        try:
            print ('{:<18s}{:>6d}{:>6s}{:>12s}{:>6d}{:>13f}{:>13f}'.format(local_load_list[i].ip_address,local_load_list[i].port,local_load_list[i].id,str(local_load_list[i].type),local_load_list[i].state,local_load_list[i].current_reqd,local_load_list[i].actual_curr))
        except:
            pass
    for i in range(len(local_source_list)):
        if i==0:
            print(dash)
            print "SOURCE LIST"
            print(dash)
            print('{:<18s}{:>6s}{:>6s}{:>12s}{:>6s}{:>13s}{:>13s}'.format("IP_ADDRESS","PORT","ID","TYPE","STATE","CURRENT","ACTUAL_CURR"))
            print (dash)
        try:
            print ('{:<18s}{:>6s}{:>6s}{:>12s}{:>6d}{:>13f}{:>13f}'.format(local_source_list[i].ip_address,local_source_list[i].port,local_source_list[i].id,str(local_source_list[i].type),local_source_list[i].state,local_source_list[i].current_aval,local_source_list[i].actual_curr))
        except:
            pass

def feedback_list_append(Feedback_list):
    par_obj = par_var()
    for i in range(par_obj.ports):
        Feedback_list.append(fb_var())
        print Feedback_list


def sorting():
    
    print "SOURCE SECTION"                
    
    with open("source_list.txt",'r') as f:
        con=f.readlines()
    #print con[0]
    con4=[]
    t=0
    if con:
        for k in con:
            con3=[]
            con1=k.split(',')
            j=0
            for i in con1:
#                print i
                con2=i.split(': ')
            
                if j==(len(con1)-1):
            #        print con2
                    con2[1]=con2[1].split('}')
                    
                    con3.append(con2[1][0])
                else:
                    if con2[1]=="None":
                        con3.append(None)
                    else:
                        con3.append(con2[1])
                j=j+1
                
            for i in con3[t]:
#                print i
                if i==None:
                    pass
            #        print "YES"
                
            con3[0]=float(con3[0])
            con3[1]=float(con3[1])
            con3[2]=float(con3[2])
            con3[3]=float(con3[3])
            con3[7]=float(con3[7])
            con3[8]=int(con3[8])
            con3[9]=float(con3[9])
            con3[10]=float(con3[10])
            
#            for i in con3:
#                print type(i)
            t=t+1
            con4.append(con3)
            
            
    print "LOAD SECTION"            
    with open("load_list.txt",'r') as f:
        con=f.readlines()
    #print con[0]
    con5 = []
    t=0
    if con:
        for k in con:
            con3=[]
            con1=k.split(',')
            j=0
            for i in con1:
#                print i
                con2=i.split(': ')
            
                if j==(len(con1)-1):
            #        print con2
                    con2[1]=con2[1].split('}')
                    
                    con3.append(con2[1][0])
                else:
                    if con2[1]=="None":
                        con3.append(None)
                    else:
                        con3.append(con2[1])
                j=j+1
                
            for i in con3[t]:
                print i
                if i==None:
                    pass
            #        print "YES"
                
            con3[0]=float(con3[0])
            con3[1]=float(con3[1])
            con3[2]=float(con3[2])
            con3[3]=float(con3[3])
            con3[7]=float(con3[7])
            con3[8]=int(con3[8])
            con3[9]=float(con3[9])
            con3[10]=float(con3[10])
            
            for i in con3:
                print type(i)
            t=t+1
            con5.append(con3)

    return con4, con5
    
    
def source_mapping(con):
    
    source_param_obj = source_param()
    print con    
    
    source_param_obj.max_curr = con[0]
    source_param_obj.min_volt = con[1]
    source_param_obj.actual_curr = con[2]
    source_param_obj.max_volt = con[3]
    source_param_obj.ip_address = con[4]
    source_param_obj.value = con[5]
    source_param_obj.id = con[6]
    source_param_obj.curr_aval = con[7]
    source_param_obj.state = con[8]
    source_param_obj.min_curr = con[9]
    source_param_obj.voltage = con[10]
    source_param_obj.type = con[11]
    source_param_obj.port = con[12]
    
    print len(con[12])
    
    return source_param_obj
    
def load_mapping(con):
        
    load_param_obj = load_param()
    
    load_param_obj.ip_address=None
    load_param_obj.port=0 
    load_param_obj.id=0 
    load_param_obj.type=0 
    load_param_obj.value=0
    load_param_obj.voltage=0
    load_param_obj.min_volt=0 
    load_param_obj.max_volt=0
    load_param_obj.min_curr=0 
    load_param_obj.max_curr=0 
    load_param_obj.current_reqd=0
    load_param_obj.state=0
    load_param_obj.actual_curr=0
    
def master_main(list_change_event,Source_list,Load_list,Feedback_list):
    
    global local_load_list
    global local_source_list
    ls=[]
    ld=[]
    feedback_list_append(Feedback_list)    
    
    bus=serial.Serial(port='/dev/ttyS0',baudrate = 115200, timeout = 2)
    if bus.closed:
        bus.open()      
    
    batt_thread = Thread(target = batt_voltage_f,args=(bus,))
    batt_thread.daemon=True     
    
    slave_poll_thread = Thread(target = poll_slave_f,args=(bus,Feedback_list))
    slave_poll_thread.daemon = True
    
#    batt_thread.start()    
    #~ print "\nBattery_thread_started"
    slave_poll_thread.start()
    print "\nslave_poll_thread_started"
    
    send_rs485_block_event.set()
    state_switch_event.set()
#    obj= parameters.load_param()
#    obj.port="2"
#    obj.state=1
#    obj.min_volt=14.2
#    obj.current_reqd=0.2
#    Load_list.append(obj) 
#    list_change_event.set()

    while True:
        list_change_event.wait()
        if list_change_event.is_set():
            list_change_event.clear()

#            local_source_list = []
#            local_load_list =[]
#            local_source_data, local_load_data=sorting()
#            if local_source_data:
#                con1=[]
#                for con_rows in local_source_data:
#                        local_source_list.append(source_mapping(con_rows))
#                        print "PRINTING CON1"
#                print con1
#                for rows in con1:
#                    print vars(rows)
#
#            if local_load_data:
#                con1=[]
#                for con_rows in local_load_data:
#                        local_load_list.append(load_mapping(con_rows))
#                        print "PRINTING CON1"
#                print con1
#                for rows in con1:
#                    print vars(rows)

#            print con

            """
            print "*************************************************"
            print "______________ ____Before LOOP_______________________"
            print "LOAD"
            print local_load_list"""  
            ld=local_load_list
            ls=local_source_list
            #~ if local_load_list:
                #~ for i in local_load_list:
                    #~ print (i)
                    #~ print vars(i)
            #~ print "SOURCE"
            #~ if local_source_list:    
                #~ for i in local_source_list:
                    #~ print (i)
                    #~ print vars(i)

            list_check_f(bus,Source_list, Load_list)
            """
            print "*************************************"
            print "LOAD"
            for i in local_load_list:
                print i
                print vars(i)
            print "SOURCE"
            for i in local_source_list:
                print i
                print vars(i)
            print "*************************************"
            """
            local_load_list = deepcopy(Load_list)
            local_source_list = deepcopy(Source_list)
            state_switch_event.clear()
            state_switch(bus,0,local_source_list,local_load_list)
            state_switch_event.set()

        
            del ld
            del ls
            
            print "___________________After LOOP________________________"
            print "LOAD"
            for i in local_load_list:
                print i
                print vars(i)
            print "SOURCE"
            for i in local_source_list:
                print i
                print vars(i)
            print "*************************************************"
            
#            f=open("source_list.txt",'w')
#            f.writelines(["%s\n"  % vars(item) for item in Source_list])
#            f.close()   
#            
#            f = open("load_list.txt", 'w')
#            f.writelines(["%s\n"  % vars(item) for item in Load_list])
#            f.close()
                
            #table(local_load_list,local_source_list)
                                    

if __name__ == "__main__":
    
    
#    Source_list= []
#    Load_list = []
#    comm_to_power_change_event = Event()
#    
#    
##    main_loop_th = Thread(target=master_main,args=(comm_to_power_change_event,Source_list,Load_list))
#    debug_thread = Thread(target=debug_code,args=())
#    debug_thread.daemon = True
#    debug_thread.start()
#
##    main_loop_th.daemon = True
##    main_loop_th.start()
#    pass
    pass
#    state_switch(0,0,0)
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Wed Feb 13 19:28:24 2019

@author: div
"""
import sys
import serial
#~ sys.path.append('/home/pi//Energy_Router/')
#from global_var import par_var
import struct
import time
import smbus
from crccheck.crc import CrcModbus
import RPi.GPIO as GPIO
from global_var import par_var, fb_var, source_param, load_param
import threading


uart_event =threading.Event()
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
GPIO.setup(18,GPIO.OUT)
class message_send:
    def crc_checksum(self,string):
#        bytearray.
        #print(hex(CrcModbus.calc(bytearray(string))))
        #print type(CrcModbus.calc(bytearray(string)))
        return CrcModbus.calc(bytearray(string))
        
    def send_rs485(self,ser,message):
        print ("send_rs485 message ->",message)        
        return ser.write(message)
            
#        return True
    def receive_rs485(self,ser,slaveid):
        GPIO.output(18,GPIO.LOW)
        #~ print "Entered receive_rs485 loop"
        flag =0
        data = []
        while True:
            try:
                incoming = ser.read(1)
                incoming1 = ord(incoming)
                #~ print incoming.encode('hex')
    #            incoming1 = (list(incoming))[0]
                #~ print incoming
                if flag ==1:
                    if i== 0:
                        data.append(incoming1)
                        #~ print ("i=0")
                    if i== 1:
                        data_len =int(incoming.encode('hex'),24)
                        data.append(incoming1)
                        #~ print ("i=1")
                    if i>1:
                        #~ print ("i>1",i)
                        data.append(incoming1)
                        if i== (data_len-2):
                            #print data
#                            print ("crc_message",crc_message)
                            string_d = ""
                            for i in data:
                                string_d = string_d + chr(i)
#                                print ("string_d",string_d)
                            #~ print ("string_d",string_d)
                            string_d = string_d
                            crc_message_result = self.crc_checksum(string_d)
                            
                            #print  ("crc_message_result", crc_message_result)
                            if crc_message_result != 0:
                                return None
                            break
                    i=i+1
                if incoming1 == slaveid:
                    #~ print "slave address check correct"
                    data.append(incoming1)
                    flag =1
                    i=0  # to check for slave condition
            except:
                return None
        return data[3:19]
            
    def send_i2c(self,ser,slave_addr,function,message,send_rs485_block_event):  # message is expecting a list 
        a=[]
        send_rs485_block_event.clear()
        print ("|||||||||||||||||||||||||   block event clear from send_i2c |||||||||||||||||||||||")
        data_size=len(message)
        if ((1+len(message))%4 !=0):
            for i in range (4-(1+len(message))%4):        
                message.append(chr(0x00))
        else:
            pass
            
        data =""
            
        for i in message:
            if type(i) is not str: 
                data =data + chr(i)
            else:
                data = data +i
        
        #~ print data_size
        msg = chr(slave_addr) + chr(function) + chr(data_size) + (data)
        check_data = self.crc_checksum(msg)
        check_high = chr(check_data>>8)
        check_low = chr(check_data & 0xFF)
        msg = msg + check_low + check_high
        #~ print "*************** i2c send ****************** "
        print msg.encode('hex')
        try:    
                #~ print "GPIO HIGH ABOVE"
                GPIO.output(18,GPIO.HIGH)
                #~ print "GPIO HIGH BELOW"
                bytes_transmit_return = self.send_rs485(ser,msg)
                #time.sleep(0.00005 *len(message))
                #~ print "byte return"
                time_p = (float (len(msg)))/10000
                #~ print "GPIO SLEEP ABOVE"
                time.sleep(time_p)
                #~ print "GPIO SLEEP BELOW"
                GPIO.output(18,GPIO.LOW)
                #~ print("slave address ",slave_addr) 
                if function == 0x80:
                    #~ print "Yes"
                    x=self.receive_rs485(ser,slave_addr)
                    time.sleep(time_p)
                    print ("|||||||||||||||||||||||||   block event set from send_i2c |||||||||||||||||||||||")
                    send_rs485_block_event.set() 
                    a= [True,x]
                    #~ print a
                    return a
                else:
                    time.sleep(time_p*4)
                print ("|||||||||||||||||||||||||   block event set from send_i2c |||||||||||||||||||||||")
                send_rs485_block_event.set() 
                return True
        except:
                #~ print "Except:"
                print ("|||||||||||||||||||||||||   block event set from send_i2c |||||||||||||||||||||||")
                send_rs485_block_event.set() 
                return False

            
        
        
        
        
    def receive_i2c(self,bus,slave_addr,command,byte_s):
        #print ("Receiving message")
#        try:
        i=0
        while True:
            try:
                return bus.read_i2c_block_data(slave_addr,command,byte_s)
                break
            except:
                if i == 5:
                    print("ERROR -> message_slave -> receive_i2c")
                    print("slave address",slave_addr)
                    break
                i = i+1
                pass
        
#        except:
#            pass


    def msg_pack(self,data,order):
        par_obj=par_var()
        total_number=len(order)
        list_msg=[]
        total_msg_size=0
        #data = ""
        for param in range(len(data)):
            if(order[param]==par_obj.VOLTAGE):
                for param_char in range(par_obj.VOLTAGE_TYPE_SIZE):
                    list_msg.append(ord(data[param][param_char]))
                #~ list_msg.append(ord(','))
            elif(order[param]==par_obj.CURRENT):
                for param_char in range(par_obj.CURRENT_TYPE_SIZE):
                    list_msg.append(ord(data[param][param_char]))
                #~ list_msg.append(ord(','))
                total_msg_size=total_msg_size+1
            elif(order[param]==par_obj.SLAVEID):
        #            msg=msg+chr(data[param])
                list_msg.append((data[param]))
                #~ list_msg.append(ord(','))
            elif(order[param]==par_obj.DIRECTION):
                list_msg.append(data[param])
                #~ list_msg.append(ord(','))
        total_msg_size=total_msg_size+2
        print list_msg
        return list_msg
        
        
        
    def msg_unpack(self,data,param_count):
        par_obj=par_var()
        parameter_list=[]
#        total_number=len(param_count)
        if data:
            for count in range(param_count):
                x=""
                for i in reversed(range(count*4,(count+1)*4)):
                    y=format(data[i],'x').zfill(2)
    #            y.format(':2s')
                    x=x+y
#            print (struct.unpack('!f',x.decode('hex'))[0])
                parameter_list.append(struct.unpack('!f',x.decode('hex'))[0])
        
            return parameter_list
        else:
            print("Connection timeout")
            return parameter_list
    def voltage_float_hex(self,v_f):
        return str(struct.pack('<f',v_f))    
    
    def current_float_hex(self,c_f):
        return str(struct.pack('<f',c_f))    
    
    def voltage_hex_float(self,v_hex_l):
#        return struct.unpack('<B', v_hex_l)
        pass

    def current_hex_float(self,c_hex_l):
        pass


if __name__ =='__main__':


    
    msg_c_obj = message_send()
    par_obj = par_var()
    ser=serial.Serial(port='/dev/ttyAMA0',baudrate = 115200, timeout = 2)
    if ser.closed:
        ser.open()
      
#4
#    ser=serial.Serial(port='/dev/ttyAMA0',baudrate = 115200)
    slave_addr = 0x32    
    function = 0x12
#
#
##    *****************************************
##    PARAMETER UPDATE COMMAND TEST
##    *****************************************
#
    voltage = 12.3
    current = 0.78
    data=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.LOAD_DIRECTION]
    data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]
    message=msg_c_obj.msg_pack(data,data_type_order)
    print message
    if msg_c_obj.send_i2c(ser,slave_addr,function,message):
        print "message sent"
#    data = ""


#    data = data + msg_c_obj.voltage_float_hex(voltage)
#    data = data + msg_c_obj.voltage_float_hex(current)
#    data = data + chr(par_obj.LOAD_DIRECTION)
#
##    data_c=[msg_c_obj.voltage_float_hex(voltage),msg_c_obj.current_float_hex(current),par_obj.LOAD_DIRECTION]
##    data_type_order=[par_obj.VOLTAGE,par_obj.CURRENT,par_obj.DIRECTION]    
##    data=msg_c_obj.msg_pack(data_c,data_type_order)
#

    """
    data_size=len(message)
    print ("Before data_size:" + str(len(message)))
    if ((1+len(message))%4 !=0):
        for i in range (4-(1+len(message))%4):        
            message.append(chr(0x00))
    else:
        pass
    
    print type(message[0])
    print ("After data_size:" + str(len(message)))
    data =""
    for i in message:
        if type(i) is not str: 
            data =data + chr(i)
        else:
            data = data +i
    msg = chr(slave_addr) + chr(function) + chr(data_size) + (data)
    print ("Message"+str(len(msg)))
    print msg
    check_data = msg_c_obj.crc_checksum(msg)
    check_high = chr(check_data>>8)
    check_low = chr(check_data & 0xFF)"""
#    
#    
#    print "*******"
    """
    msg = msg + check_low + check_high
    print msg.encode('hex')"""
#    GPIO.output(4,GPIO.HIGH)
#    msg_c_obj.send_rs485(ser,message)
    
    

#    *****************************************
#    POLL SLAVE RECEIVE COMMAND TEST
#    *****************************************print ser.inWaiting()
    """   
    msg_c_obj = message_send()
    par_obj = par_var()

    ser=serial.Serial(port='/dev/ttyAMA0',baudrate = 115200, timeout = 2)
    if ser.closed:
        ser.open()
    msg_recv =message_send()
    
    while True:
        time.sleep(0.5)
        uart_event.clear()
        slave_addr = 0x32    
        function = 0x80
        data = "2"   

        receive_thread  = threading.Thread(target=msg_recv.receive_rs485,args=[ser,])
        receive_thread.daemon =True
        #receive_thread.start()
        '''
        
        #   FOR SMBUS CODING
        
            bus=smbus.SMBus(1) 
            msg_c_obj = message_send()
            time.sleep(4)
            msg_c_obj.send_i2c(bus,0x32,0x80,[8])
            time.sleep(3)
            x=msg_c_obj.receive_i2c(bus,0x32,0x23,8)
            print x
            param=msg_c_obj.msg_unpack(x,2)
        '''
        data_size = len(data)
        #print ("Before data_size:" + str(len(data)))
        if ((1+len(data))%4 !=0):
            for i in range (4-(1+len(data))%4):        
                data = data + chr(0x00)
        else:
            pass
        #print ("After data_size:" + str(len(data)))
        #print data_size
        message = chr(slave_addr) + chr(function) + chr(data_size) + (data)
        #print ("Message"+str(len(message)))
        #print message
        check_data = msg_c_obj.crc_checksum(message)
        check_high = chr(check_data>>8)
        check_low = chr(check_data & 0xFF)
        
        
        #print "*******"
        message = message + check_low + check_high
        #print (message)
        GPIO.output(18,GPIO.HIGH)
    #    time.sleep(0.03)
        bytes_transmit_return = msg_c_obj.send_rs485(ser,message)
        #time.sleep(0.00005 *len(message))
        
        time_p = (float (len(message)))/10000
        time.sleep(time_p)
        
        GPIO.output(18,GPIO.LOW)
    #    print ser.out_waiting(3242) 
        
        
        
        
        ser.reset_input_buffer()
        #print(bytes_transmit_return)
        time.sleep(0.0006)  # FIND how to remove this timeout: since gpio get low before data is fully sent out    
        GPIO.output(18,GPIO.LOW)
        #uart_event.set()
        data =[]
        i=0
        t =time.time()
        flag =0
        data = []
        ser.reset_input_buffer()
        ser.reset_output_buffer()
    
        while True:
    
            if (ser.in_waiting>0):
    #            print ser.in_waiting
                incoming = ser.read(1)
                incoming = incoming.encode('hex')
                if flag ==1:
                    if i== 0:
                        data.append(incoming)
                    if i== 1:
                        data_len =int(incoming,16)
                        data.append(incoming)
                    if i>1:
                        data.append(incoming)
                        if i== (data_len-2):
                            break
                    i=i+1
                if incoming == "32":
                    #print "slave_address condition"
                    data.append(incoming)
                    flag =1
                    i=0  # to check for slave condition
                    #print incoming
        print data
    ser.close()"""
    #             except serial.serialutil.SerialException:
    #                print("No data this time")
     #   print(data)
    #    while True:
    #            if ser.inWaiting() > 0:
    #                data = ser.read()
    #            #print ser.inWaiting()
    #                print data.encode('hex')
    #    time.sleep(0.03)
    #    while True:
    #        pass
    #    print ser.inWaiting()
        #   rcd_message = msg_c_obj.receive_rs485(ser)
        #print rcd_message
       
